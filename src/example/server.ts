// generated by ts-bicycle
// do not edit by hand

import Schema from 'bicycle/types/Schema';
import SchemaKind from 'bicycle/types/SchemaKind';
import QueryContext from 'bicycle/types/QueryContext';
import Query from 'bicycle/types/Query';
import * as ScalarTypes from './scalar-types';
import MutationContext from 'bicycle/types/MutationContext';
import BicycleServer, {Options} from 'bicycle/server-core';
import Person from './objects/Person';
import {Root} from './objects/Root';
import Invite from './objects/Other';
import {validateEmail} from './scalars/Email';
import {validate as validateRichText} from './scalars/RichText';
import _Context0 from './Context';

// root never has any actual data, so we create one reusable instance
const root = new Root({});
const schema: Schema<_Context0> = {
  Person: {
    kind: SchemaKind.NodeType,
    name: 'Person',
    description: undefined,
    id(obj: Person, ctx: _Context0, qCtx: QueryContext<_Context0>): string {
      return '' + obj.data.id;
    },
    matches(obj: any): obj is Person {
      return obj instanceof Person;
    },
    fields: {
      id: {
        kind: SchemaKind.FieldMethod,
        name: 'id',
        description: undefined,
        resultType: {
          kind: 'Number',
          loc: {fileName: '/src/example/objects/Person.ts', line: 12},
        } as any,
        argType: {kind: SchemaKind.Void},
        auth: 'public',
        resolve(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): number {
          return value.data.id;
        },
      },
      name: {
        kind: SchemaKind.FieldMethod,
        name: 'name',
        description: undefined,
        resultType: {
          kind: 'Union',
          elements: [{kind: 'Null'}, {kind: 'String'}],
          loc: {fileName: '/src/example/objects/Person.ts', line: 13},
        } as any,
        argType: {kind: SchemaKind.Void},
        auth: 'public',
        resolve(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): null | string {
          return value.data.name;
        },
      },
      friends: {
        kind: SchemaKind.FieldMethod,
        name: 'friends',
        description: undefined,
        resultType: {
          kind: 'List',
          element: {kind: 'Named', name: 'Person'},
        } as any,
        argType: {
          kind: 'Void',
          loc: {fileName: '/src/example/objects/Person.ts', line: 26},
        } as any,
        auth(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): boolean | PromiseLike<boolean> {
          return value.$isSelf(args, context);
        },
        resolve(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): Person[] | PromiseLike<Person[]> {
          return value.friends(args, context);
        },
      },
      enemies: {
        kind: SchemaKind.FieldMethod,
        name: 'enemies',
        description: undefined,
        resultType: {
          kind: 'List',
          element: {kind: 'Named', name: 'Person'},
        } as any,
        argType: {
          kind: 'Void',
          loc: {fileName: '/src/example/objects/Person.ts', line: 31},
        } as any,
        auth(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): boolean | PromiseLike<boolean> {
          return value.$isSelf(args, context);
        },
        resolve(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): Person[] | PromiseLike<Person[]> {
          return value.enemies(args, context);
        },
      },
      objectWithOptionalProperty: {
        kind: SchemaKind.FieldMethod,
        name: 'objectWithOptionalProperty',
        description: undefined,
        resultType: {
          kind: 'Object',
          properties: {
            foo: {
              kind: 'Union',
              elements: [
                {
                  kind: 'String',
                  loc: {fileName: '/src/example/objects/Person.ts', line: 37},
                },
                {kind: 'Void'},
              ],
              loc: {fileName: '/src/example/objects/Person.ts', line: 37},
              isOptional: true,
            },
          },
          loc: {fileName: '/src/example/objects/Person.ts', line: 37},
        } as any,
        argType: {kind: 'Void'} as any,
        auth: 'public',
        resolve(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): {'foo'?: string} | PromiseLike<{'foo'?: string}> {
          return value.objectWithOptionalProperty();
        },
      },
      enumField: {
        kind: SchemaKind.FieldMethod,
        name: 'enumField',
        description: undefined,
        resultType: {
          kind: 'Union',
          elements: [
            {kind: 'Literal', value: 10},
            {kind: 'Literal', value: 20},
          ],
          enumDeclaration: 'MyEnum',
          loc: {fileName: '/src/example/objects/Person.ts', line: 40},
        } as any,
        argType: {kind: 'Void'} as any,
        auth: 'public',
        resolve(
          value: Person,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): ScalarTypes.MyEnum | PromiseLike<ScalarTypes.MyEnum> {
          return value.enumField();
        },
      },
    },
    mutations: {
      set: {
        kind: SchemaKind.Mutation,
        name: 'set',
        description: undefined,
        resultType: {kind: 'Void'} as any,
        argType: {
          kind: 'Object',
          properties: {
            field: {
              kind: 'String',
              loc: {fileName: '/src/example/objects/Person.ts', line: 53},
            },
            value: {
              kind: 'String',
              loc: {fileName: '/src/example/objects/Person.ts', line: 53},
            },
          },
          loc: {fileName: '/src/example/objects/Person.ts', line: 53},
        } as any,
        auth: 'public',
        resolve(
          args: {'field': string; 'value': string},
          context: _Context0,
          mCtx: MutationContext<_Context0>,
        ): void | PromiseLike<void> {
          return Person.set(args, context);
        },
      },
    },
  },
  Root: {
    kind: SchemaKind.NodeType,
    name: 'Root',
    description: undefined,
    id(): string {
      return 'root';
    },
    matches(obj: any): obj is Root {
      return obj instanceof Root;
    },
    fields: {
      people: {
        kind: SchemaKind.FieldMethod,
        name: 'people',
        description: undefined,
        resultType: {
          kind: 'List',
          element: {kind: 'Named', name: 'Person'},
        } as any,
        argType: {
          kind: 'Void',
          loc: {fileName: '/src/example/objects/Root.ts', line: 12},
        } as any,
        auth: 'public',
        resolve(
          value: _Context0,
          args: void,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): Person[] | PromiseLike<Person[]> {
          return root.people(args, context);
        },
      },
      person: {
        kind: SchemaKind.FieldMethod,
        name: 'person',
        description: undefined,
        resultType: {kind: 'Named', name: 'Person'} as any,
        argType: {
          kind: 'Number',
          loc: {fileName: '/src/example/objects/Root.ts', line: 15},
        } as any,
        auth: 'public',
        resolve(
          value: _Context0,
          args: number,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): Person | PromiseLike<Person> {
          return root.person(args, context);
        },
      },
      peopleByEmail: {
        kind: SchemaKind.FieldMethod,
        name: 'peopleByEmail',
        description: undefined,
        resultType: {
          kind: 'List',
          element: {kind: 'Named', name: 'Person'},
        } as any,
        argType: {
          kind: 'Named',
          name: 'Email',
          loc: {fileName: '/src/example/objects/Root.ts', line: 18},
        } as any,
        auth: 'public',
        resolve(
          value: _Context0,
          args: ScalarTypes.Email,
          context: _Context0,
          subQuery: true | Query,
          qCtx: QueryContext<_Context0>,
        ): Person[] | PromiseLike<Person[]> {
          return root.peopleByEmail(args, context);
        },
      },
    },
    mutations: {},
  },
  Invite: {
    kind: SchemaKind.NodeType,
    name: 'Invite',
    description: undefined,
    id(obj: Invite, ctx: _Context0, qCtx: QueryContext<_Context0>): string {
      return '' + obj.data.id;
    },
    matches(obj: any): obj is Invite {
      return obj instanceof Invite;
    },
    fields: {},
    mutations: {},
  },
  Email: {
    kind: SchemaKind.Scalar,
    name: 'Email',
    description: undefined,
    baseType: {
      kind: 'String',
      loc: {
        fileName:
          '/Users/forbeslindesay/GitHub/ts-bicycle/src/example/scalars/Email.ts',
        line: 7,
      },
    } as any,
    validate: validateEmail,
  },
  RichText: {
    kind: SchemaKind.Scalar,
    name: 'RichText',
    description: undefined,
    baseType: {
      kind: 'Object',
      properties: {
        ___html: {
          kind: 'String',
          loc: {
            fileName:
              '/Users/forbeslindesay/GitHub/ts-bicycle/src/example/scalars/RichText.ts',
            line: 3,
          },
        },
      },
      loc: {
        fileName:
          '/Users/forbeslindesay/GitHub/ts-bicycle/src/example/scalars/RichText.ts',
        line: 7,
      },
    } as any,
    validate: validateRichText,
  },
};
export {Options};
export default class Server extends BicycleServer<_Context0> {
  constructor(options?: Options) {
    super(schema, options);
  }
}
